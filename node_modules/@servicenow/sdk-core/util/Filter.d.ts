/**
 * From T, construct a union of the keys which are assignable to U
 *
 * @param Mode If set to 'invert', will use keys to which U is assignable
 */
export type SelectKeys<T, U, Mode extends 'normal' | 'invert' = 'normal'> = {
    [P in keyof T]-?: Mode extends 'normal' ? (T[P] extends U ? P : never) : U extends T[P] ? P : never;
}[keyof T];
/**
 * From T, construct a union of the keys which are not assignable to U
 *
 * @param Mode If set to 'invert', will use keys to which U is not assignable
 */
export type ExcludeKeys<T, U, Mode extends 'normal' | 'invert' = 'normal'> = {
    [P in keyof T]-?: Mode extends 'normal' ? (T[P] extends U ? never : P) : U extends T[P] ? never : P;
}[keyof T];
/**
 * Construct a new type with only the properties of T which are assignable to U
 */
export type FilterIn<T, U, Mode extends 'normal' | 'invert' = 'normal'> = T extends Record<PropertyKey, unknown> ? {
    [K in keyof Pick<T, SelectKeys<T, U, Mode>>]: U & T[K];
} : T;
/**
 * Construct a new type with all the properties of T, except those which are assignable to U
 */
export type FilterOut<T, U, Mode extends 'normal' | 'invert' = 'normal'> = T extends Record<PropertyKey, unknown> ? {
    [K in keyof Pick<T, ExcludeKeys<T, U, Mode>>]: T[K];
} : T;
/**
 * Construct a type that accepts any string but also a list of suggestions (Ex. <'suggestion 1' | 'suggestion 2'>)
 */
export type StringWithSuggestions<T> = T | (string & Record<never, never>);
